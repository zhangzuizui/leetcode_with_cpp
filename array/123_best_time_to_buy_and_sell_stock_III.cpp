/* 之前一直隐隐有思路但是就是不对，这是为什么
 * 很显而易见的，这是个最优化问题，使用动态规划解决
 * 所以问题的关键就变成了子问题的拆分
 * 这个问题不应该这样分： 数组分成左右两段 两段中分别找卖一次的最大钱
 * 这根本不是子问题也无法下手
 * 那么子问题应该怎么找？
 * 容易知道这道题扩展一下，其实就是最多交易k次，赚最多的钱
 * 现在就需要想一下当交易k-1次是，应该满足什么情况
 * 很显而易见的就是，对于当前遍历到的元素及其左边的元素，在最多交易k-1次的情况下，具有最高利润
 * 简单的说就是当需要找这第k次交易的时候，我们手里已经有最多的钱了
 * 那么问题就转化为了，现在我们手里有X元，在剩下的数组[A1,A2,A3,...,A4]中最多交易一次，求怎样交易手里的钱最多。
 * 那么什么时候买入，什么时候卖？
 * 考虑到实际上这个子问题并不是一个独立的问题，需要与之前的k-1次联系起来。
 * 一方面，剩下的数组，已经是联系的一部分了，另一方面的联系就是利润
 * 对于真正单次操作的 买入最便宜的股票，就变为了买入该股后手里能否保留更多的钱
 * 卖酒都是一样了的，保证卖后手里的钱最多即可
 */
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        int gain1 = 0, gain2 = 0;
        int buy1 = INT_MIN, buy2 = INT_MIN;
        for (int i = 0; i < len; ++i) {
            gain2 = max(gain2, prices[i] + buy2);
            buy2 = max(buy2, gain1 - prices[i]);
            gain1 = max(gain1, prices[i] + buy1);
            buy1 = max(buy1, -prices[i]);
            //cout << "buy1 = " << buy1 << "\tgain1 = " << gain1 << "\tbuy2 = " << buy2 <<  "\tgain2 = " << gain2 << "\tprices[i] = " << prices[i] << endl;
        }
        return gain2;
    }
};