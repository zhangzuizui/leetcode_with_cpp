/*
 *这个题有两点，
 *首先要搞明白什么时候是最大面积矩形块，如下
 *更小[大.....小.......大]更小
 *其实就是将问题进行拆分了，解题的过程肯定要对数组进行扫描，
 *容易想到的是，对扫描的每一块都进行一个判断，如果下一块比它大会怎么样，
 *下一块比它小会怎么样。容易知道的是对于指定块A，如果下一块比A大，
 *其面积的增加是与A相关的，如果下一块比A小的话，其面积的增加与A的下一块相关，
 *即可以想象成A的下一块又是一个新的A了，因为面积是由更小的那块的值决定的。
 *那么显而易见的----既然找到一个小块儿后，面积与A无关了，那我们要找的最面积，
 *跟A的高度其实也没什么关系了，此时根据已经扫描了的元素，
 *可以算出与A相关的矩形的最大面积----其实就是上面方括号框起来的情况\
 *第二点就很简单了，就是用一个栈存放一个到目前为止未得到面积最大情况的点们的下标，
 *根据第一点的分析容易知道，这个栈里存放的下标对应的值的序列，是一个递增序列
 *因为遇到更小的值的时候，就能算出之前那些更大值对应的最大面积了，
 *所以更大值对应的面积计算完之后就没卵用了，弹出即可
*/
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if (heights.empty()) return 0;
        int max_area = 0;
        heights.push_back(0);
        stack<int> s;
        s.push(-1);
        for (int i = 0; i < heights.size(); ++i) {
            while (s.top() != -1 && heights[i] < heights[s.top()]) {
                int h = heights[s.top()];
                s.pop();
                max_area = max(max_area, h * (i - s.top() - 1));
                //cout << i << '\t' << h << '\t' << max_area << endl;
            }
            s.push(i);
        }
        return max_area;
    }
};